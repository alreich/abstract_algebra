Abstract Algebra
================

A pedagogical implementation of **Finite Algebras** in Python: Groups,
Rings, Fields, Vector Spaces, Modules, Monoids, Semigroups, and Magmas.

Currently the representation of an algebra here depends on being able to
explicitely represent its Cayley table. Consequently, only relatively
small algebras can be represented - few hundred elements at most.

Summary
-------

The ``finite_algebras`` module contains class definitions, methods, and
functions for working with algebras that only have a **finite number of
elements**.

-  The primary constructor of algebras is the function,
   ``make_finite_algebra``. It examines the properties of the input
   table and returns the appropriate instance of an algebra.
-  Algebras can be input from, or output to, JSON files/strings or
   Python dictionaries.
-  Each algebra is defined by name (``str``), a description (``str``), a
   list of *element names* (``str``) and a square, 2-dimensional table
   that defines a binary operation (``list`` of ``lists`` of ``int``).
   Rings & Fields have two such tables.
-  Each algebra has methods for examining its properties (e.g.,
   ``is_associative``, ``is_commutative``, ``center``, ``commutators``,
   etc.)
-  Algebraic elements can be “added” (or “multiplied”) via their binary
   operations (e.g., ``v4.op('h','v') ==> 'r'``).
-  Inverses & identities can be obtained, if the algebra supports them
   (e.g., ``z3.inv('a') = 'a^2'``, ``z3.identity ==> 'e'``).
-  Direct products of two or more algebras can be computed using
   Python’s multiplication operator (e.g., ``z4 * v4``).
-  If two algebras are isomorphic, the mapping between their elements
   can be determined (e.g.,
   ``v4.isomorphic(z2 * z2) ==> {'h': 'e:a', 'v': 'a:e', 'r': 'a:a', 'e': 'e:e'}``)
-  Autogeneration of some types of algebras, of arbitrary order, is
   supported (e.g., symmetric, cyclic).
-  Subalgebras (e.g., subgroups) can be determined, along with related
   functionality (e.g, ``is_normal()``).
-  Groups, Rings, and Fields can be used to construct Modules and Vector
   Spaces, including n-dimensional Modules and Vector Spaces using the
   direct products of Rings and Fields, resp.
-  The Regular Representation of a Monoid, Group, or the additive
   abelian Group of a Ring or Field, can be computed in either dense or
   sparse matrix form.

Installation
------------

This module runs under Python 3.7+ and requires **NumPy**.

Clone the github repository to install:

$ git clone https://github.com/alreich/abstract_algebra.git

Documentation
-------------

See full documentation at
`ReadTheDocs <https://abstract-algebra.readthedocs.io/en/latest/index.html>`__.

Quick Look
----------

**Create an algebra:**

.. code:: ipython3

    >>> from finite_algebras import make_finite_algebra
    
    >>> V4 = make_finite_algebra('V4',
                                 'Klein-4 group',
                                 ['e', 'h', 'v', 'r'],
                                 [[0, 1, 2, 3],
                                  [1, 0, 3, 2],
                                  [2, 3, 0, 1],
                                  [3, 2, 1, 0]])
    >>> V4




.. parsed-literal::

    Group(
    'V4',
    'Klein-4 group',
    ['e', 'h', 'v', 'r'],
    [[0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]]
    )



**Look at the algebra’s properties:**

.. code:: ipython3

    >>> V4.about(use_table_names=True)


.. parsed-literal::

    
    ** Group **
    Name: V4
    Instance ID: 4359203792
    Description: Klein-4 group
    Order: 4
    Identity: e
    Commutative? Yes
    Cyclic?: No
    Elements:
       Index   Name   Inverse  Order
          0       e       e       1
          1       h       h       2
          2       v       v       2
          3       r       r       2
    Cayley Table (showing names):
    [['e', 'h', 'v', 'r'],
     ['h', 'e', 'r', 'v'],
     ['v', 'r', 'e', 'h'],
     ['r', 'v', 'h', 'e']]


**Autogenerate a small cyclic group:**

.. code:: ipython3

    >>> from finite_algebras import generate_cyclic_group
    
    >>> Z2 = generate_cyclic_group(2)
    
    >>> Z2.about()


.. parsed-literal::

    
    ** Group **
    Name: Z2
    Instance ID: 4372297040
    Description: Autogenerated cyclic Group of order 2
    Order: 2
    Identity: e
    Commutative? Yes
    Cyclic?: Yes
      Generators: ['a']
    Elements:
       Index   Name   Inverse  Order
          0       e       e       1
          1       a       a       2
    Cayley Table (showing indices):
    [[0, 1], [1, 0]]


**Compute the Direct Product of the cyclic group with itself:**

.. code:: ipython3

    >>> Z2_sqr = Z2 * Z2
    
    >>> Z2_sqr.about(use_table_names=True)


.. parsed-literal::

    
    ** Group **
    Name: Z2_x_Z2
    Instance ID: 4385822992
    Description: Direct product of Z2 & Z2
    Order: 4
    Identity: e:e
    Commutative? Yes
    Cyclic?: No
    Elements:
       Index   Name   Inverse  Order
          0     e:e     e:e       1
          1     e:a     e:a       2
          2     a:e     a:e       2
          3     a:a     a:a       2
    Cayley Table (showing names):
    [['e:e', 'e:a', 'a:e', 'a:a'],
     ['e:a', 'e:e', 'a:a', 'a:e'],
     ['a:e', 'a:a', 'e:e', 'e:a'],
     ['a:a', 'a:e', 'e:a', 'e:e']]


**Are z2_sqr & v4 isomorphic?**

**Yes, the method ``isomorphic`` finds the following mapping between
their elements:**

.. code:: ipython3

    >>> V4.isomorphic(Z2_sqr)




.. parsed-literal::

    {'e': 'e:e', 'h': 'e:a', 'v': 'a:e', 'r': 'a:a'}



**The method, ``regular_representation``, computes a mapping, :math:`M`,
between a group, :math:`G = \langle A, \circ \rangle`, and a set of
matrices such that**

-  :math:`n = |A|` is the order of the group
-  :math:`M(e) = I_n`, where :math:`e` is the group’s identity element
   and :math:`I_n` is the :math:`n x n` identity matrix
-  :math:`M(a_i) \cdot M(a_j) = M(a_i \circ a_j)` for all
   :math:`a_i, a_j \in A`

.. code:: ipython3

    >>> M, _, _, _ = V4.regular_representation()
    >>> for elem in M:
    >>>     print(elem)
    >>>     print(M[elem])
    >>>     print()


.. parsed-literal::

    e
    [[1. 0. 0. 0.]
     [0. 1. 0. 0.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]]
    
    h
    [[0. 1. 0. 0.]
     [1. 0. 0. 0.]
     [0. 0. 0. 1.]
     [0. 0. 1. 0.]]
    
    v
    [[0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [1. 0. 0. 0.]
     [0. 1. 0. 0.]]
    
    r
    [[0. 0. 0. 1.]
     [0. 0. 1. 0.]
     [0. 1. 0. 0.]
     [1. 0. 0. 0.]]
    

