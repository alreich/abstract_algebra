# def get_cached_value(cached_value, accessor):
    def __init__(self, name, description, elements, table):
    def __eq__(self, other):
    def __contains__(self, element):
    def __getitem__(self, index):
    def __repr__(self):
    def __str__(self):
    def elements(self):
    def table(self):
    def identity_index(self):
    def identity(self):
    def set_elements(self, new_elements):
    def order(self):
    def table_as_list_with_names(self):
    def is_associative(self):
    def is_commutative(self):
    def is_abelian(self):
    def has_inverses(self):
    def to_dict(self):
    def dumps(self):
    def dump(self, json_filename):
    def about(self, max_size=12, use_table_names=False):
    def __init__(self, name, description, elements, table):
    def op(self, *args):
        """Return the 'product' or 'sum' of 1 or more algebra elements as defined by the
    def direct_product_delimiter(self, delimiter=None):
        """If no input, then the current direct product element name delimiter will be returned (default is ':').
    def __mul__(self, other):  # Direct Product of two Magmas
    def __init__(self, name, description, elements, table):
    def __init__(self, name, description, elements, table):
    # def identity(self):
    # def identity(self):
    def element_order(self, element):
        def order_aux(elem, prod, order):
    def element_mappings(self, other):
    def isomorphic_mapping(self, other, mapping):
    def isomorphic(self, other):
    def __init__(self, name, description, elements, table):
    def create_inverse_lookup_dict(self):
    def inv(self, element):
    def conj(self, a, g):
    def is_normal(self, subgrp):
    def closure(self, subset_of_elements):
    def closed_proper_subsets_of_elements(self):
    def subgroup_from_elements(self, closed_subset_of_elements, name="No name", desc="No description"):
        #       Use the is_closed method (To Be Written) defined, above.
    def proper_subgroups(self):
    def trivial_subgroups(self):
    def subgroups(self):
    def unique_proper_subgroups(self, subgroups=None):
def generate_cyclic_group(order, identity_name="e", elem_name="a", name=None, description=None):
def generate_symmetric_group(n, name=None, description=None, base=1):
def powerset(iterable):
def generate_powerset_group(n, name=None, description=None):
    def __init__(self, *args):
    def ring_elements(self):
    def add_identity(self):
    def add(self, *args):
    def ring_op(self, *args):
    def mult_identity(self):
    def has_mult_identity(self):
    def is_distributive(self, verbose=False):
    def ring_mult_table_with_names(self):
    def pprint(self, use_element_names=False):
def powerset_mult_table(n):
def generate_powerset_ring(n, name=None, description=None):
def make_finite_algebra(*args):
def index_table_from_name_table(elements, name_table):
def partition_into_isomorphic_lists(list_of_groups):
    def iso_and_not_iso(gp, gps):
    def aux(result, remainder):
    def __init__(self, permutation):
    def __eq__(self, other):
    def __hash__(self):
    def __repr__(self):
    def __len__(self):
    def __mul__(self, other):
    def __init__(self, arr):
    def __repr__(self):
    def __str__(self):
    def __eq__(self, other):
    def __getitem__(self, tup):
    def order(self):
    def table(self):
    def tolist(self):
    def is_associative(self):
    def is_commutative(self):
    def left_identity(self):
    def right_identity(self):
    def identity(self):
    def has_inverses(self):
    def inverse_lookup_dict(self, identity):
    def about(self, printout=False):
def about_tables(list_of_cayley_tables):
class FiniteAlgebra:
        return f"{self.__class__.__name__}(\n{nm},\n{desc},\n{elems},\n{tbl}\n)"
        return f"{self.__class__.__name__}({nm}, {desc}, {elems}, {tbl})"
        return {'type': self.__class__.__name__,
        print(f"\n{self.__class__.__name__}: {self.name}\n{self.description}")
            print(f"{self.__class__.__name__} order is {size} > {max_size}, so no further info calculated/printed.")
class Magma(FiniteAlgebra):
        return self.__class__(dp_name,
class Semigroup(Magma):
class Monoid(Semigroup):
class Group(Monoid):
class Ring(Group):
        print(f"{self.__class__.__name__}('{self.name}',")
class Perm:
class CayleyTable:
        # return f"{self.__class__.__name__}(\n{pp.pformat(self.__table.tolist())}\n)"
        return f"{self.__class__.__name__}({self.__table.tolist()})"
        return f"{self.__class__.__name__}({self.__table.tolist()})"
