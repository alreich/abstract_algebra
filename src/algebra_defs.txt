             'Klein-4 group again -- defined using element names in the mult_table',
    def __init__(self, *args):
    def __str__(self):
    def __repr__(self):
    def __len__(self):
    def __contains__(self, element_name):
    def __getitem__(self, index):
    def make_empty_element_order_cache(self):
    def elements(self):
    def set_elements(self, new_element_names):
    def order(self):
    def element_order(self, element):
        def order_aux(elem, prod, order):
    def __eq__(self, other):
    def identity(self):
    def deepcopy(self):
    def direct_product_delimiter(self, delimiter=None):
        """If no input, then the current direct product element name delimiter will be returned (default is ':').
    def create_inverse_lookup_dict(self):
    def to_dict(self):
    def dumps(self):
    def dump(self, json_filename):
    def inv(self, element_name):
    def conj(self, a, g):
    def mult_table_with_names(self):
    def mult(self, *args):
    def pprint(self, use_element_names=False):
        to create a copy of the Group.  By default, the four basic components of the Group
    def is_associative(self):
    def __mul__(self, other):
    def about(self, max_size=12, use_table_names=False):
    def about_proper_subgroups(self, unique=False, show_elements=True):
    def is_abelian(self):
    def is_commutative(self):
    def is_normal(self, subgrp):
    def closure(self, subset_of_elements):
    def closed_proper_subsets_of_elements(self):
    def subgroup_from_elements(self, closed_subset_of_elements, name="No name", desc="No description"):
          The subgroup defined by the input closed subset of elements
        #       Use the is_closed method (To Be Written) defined, above.
    def proper_subgroups(self):
    def trivial_subgroups(self):
    def subgroups(self):
    def unique_proper_subgroups(self, subgroups=None):
    def reorder_elements(self, reordered_elements):
    def element_mappings(self, other):
    def isomorphic_mapping(self, other, mapping):
    def isomorphic(self, other):
def generate_cyclic_group(order, identity_name="e", elem_name="a", name=None, description=None):
def powerset(iterable):
def get_duplicates(lst):
def check_inputs(element_names, mult_table):
def divide_groups_into_isomorphic_sets(list_of_groups):
    def iso_and_not_iso(gp, gps):
    def aux(result, remainder):
def index_table_from_name_table(name_table):
def make_table(table_string):
def __no_conflict(p1, p2):
def __no_conflicts(items):
def __filter_out_conflicts(perms, perm, n):
def generate_all_group_tables(order):
def tables_to_groups(tables, identity_name="e", elem_name="a"):
def is_table_associative(table):
def get_integer_form(elem_list):
def get_int_forms(ref_group, isomorphisms):
    def __init__(self, permutation):
    def __eq__(self, other):
    def __hash__(self):
    def __repr__(self):
    def __len__(self):
    def __mul__(self, other):
def generate_symmetric_group(n, name=None, description=None, base=1):
      The default is 1, so permutations will be
def generate_powerset_group(n, name=None, description=None):
def powerset_mult_table(n):
    def __init__(self, *args):
    def ring_elements(self):
    def add_identity(self):
    def add(self, *args):
    def ring_mult(self, *args):
    def mult_identity(self):
    def has_mult_identity(self):
    def is_distributive(self, verbose=False):
    def ring_mult_table_with_names(self):
    def pprint(self, use_element_names=False):
def generate_powerset_ring(n, name=None, description=None):
class Group:
        """Return a string that identifies the object's class, name, and description."""
        return f"<{self.__class__.__name__}: {self.name}, {self.description}>"
        return f"{self.__class__.__name__}('{nm}',\n'{desc}',\n{elems},\n{tbl.tolist()}) "
        return {'type': self.__class__.__name__,
        print(f"{self.__class__.__name__}('{self.name}',")
        return self.__class__(dp_name,
        print(f"\n{self.__class__.__name__}: {self.name}\n{self.description}")
            print(f"{self.__class__.__name__} order is {size} > {max_size}, so no further info calculated/printed.")
class Perm:  # Permutation
class Ring(Group):
        print(f"{self.__class__.__name__}('{self.name}',")
class Field(Ring):
